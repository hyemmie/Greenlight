<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    {% load static %} <!-- 추가 --> 
    <link rel="stylesheet" href="{% static 'map/index.css' %}">
</head>
<body>
    <div id="chart"></div>
    <div id="title">
        <h2>그린라이트를 '좀만 더' 켜줘</h2>
        <p> 서울시 길이 40m 이상의 횡단보도 점등시간 시각화</p>
        <br/>
        <p> 2020-1 비주얼라이제이션<br/>
          열시에 만나조 : 김민균, 백지수, 윤아람, 이사은, 이혜민
        </p>
        <p> Reference <br/>
          <a href="http://www.wikitree.co.kr/main/news_view.php?id=217101">Data</a> by Wikitree</a>
          and <a href="https://gist.github.com/e9t/ba9edd99793a5c91eaab">code</a>
          by <a href="http://lucypark.kr">Lucy Park</a>
          <br>
          <a href="http://opensource.org/licenses/Apache-2.0">Licensed with Apache 2.0</a>
        </p>
    </div>
    
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script>
    var width = 1080,
        height = 700;

    var minColor = 'yellow',
        maxColor = 'red';

    var minValue = 5,
        maxValue = 35; // TODO: automate

    var legendWidth = 15,
        legendHeight = 150,
        margin = { left: 40, top: 30 };

  // define color scale
    var colorScale = d3.scale.linear()
        .range([minColor, maxColor]) // or use hex values
        .domain([minValue, maxValue]);

    var sizeScale = d3.scale.linear()
        .domain([minValue, maxValue]);

  // define projection and path
    var projection = d3.geo.mercator()
        .center([126.9895, 37.5651])
        .scale(80000)
        .translate([2*width/5, height/2]);

    var path = d3.geo.path().projection(projection);

  // add canvas
    var svg = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height);

    var map = svg.append("g").attr("id", "map"),
        points = svg.append("g").attr("id", "places"),
        legend = svg.append("g").attr("id", "legend");

  // add legend for colors
    var legendBar = legend.append("defs").append("linearGradient")
        .attr("id", "gradient")
        .attr("x1", "100%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "100%")
        .attr("spreadMethod", "pad");

    legendBar.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", maxColor)
        .attr("stop-opacity", 1);

    legendBar.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", minColor)
        .attr("stop-opacity", 1);

    legend.append("rect")
        .attr("width", legendWidth)
        .attr("height", legendHeight)
        .style("fill", "url(#gradient)")
        .style("opacity", 0.5)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var y = d3.scale.linear().range([legendHeight, 0]).domain([minValue, maxValue]);
    var yAxis = d3.svg.axis().scale(y).orient("right");

    legend.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + (legendWidth + margin.left) + "," + margin.top + ")")
        .call(yAxis)
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 30)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("(단위: %)");

  // add map
    d3.json("{% static 'map/seoul_municipalities_topo_simple.json' %}", function(error, data) {
        var features = topojson.feature(data, data.objects.seoul_municipalities_geo).features;
        map.selectAll('path')
            .data(features)
        .enter().append('path')
            .attr('class', function(d) { console.log(); return 'municipality c' + d.properties.code })
            .attr('d', path);

        map.selectAll('text')
            .data(features)
        .enter().append('text')
            .attr('transform', function(d) { return 'translate(' + path.centroid(d) + ')'; })
            .attr('dy', '.35em')
            .attr('class', 'municipality-label')
        .text(function(d) { return d.properties.name; })
  });

  // add circles
    d3.csv("{% static 'map/places.csv'%}", function(data) {
        var point = points.selectAll("circle")
            .data(data.filter(function(d) { return d.filter==="red"; }))
        .enter().append("a")
            // .attr("xlink:href", function(d) { return d.url }); 

        point.append("circle")
            .attr("cx", function(d) { return projection([d.lon, d.lat])[0]; })
            .attr("cy", function(d) { return projection([d.lon, d.lat])[1]; })
            .attr("r", 6)
            .style("fill", function(d) { return colorScale(d.price); });

    // add circle labels
        var labels = [],
            labelLinks = [];

    data.forEach(function(d, i) {
        var p = projection([d.lon, d.lat]);
        var node = {
            //label: d.name,
            x: p[0],
            y: p[1]
      };
      labels.push({node : node }); labels.push({node : node }); // push twice
      labelLinks.push({ source : i * 2, target : i * 2 + 1, weight : 1, x: 100 });
    });

    var force = d3.layout.force()
        .nodes(labels)
        .links(labelLinks)
        .gravity(0)
        .linkDistance(0)
        .linkStrength(8)
        .charge(-100)
        .size([width, height])
        .on("tick", tick);

    function tick() {
      circleNode.call(updateNode);
      labelNode.each(function(d, i) {
        if(i % 2 == 0) {
          d.x = d.node.x;
          d.y = d.node.y;
        } else {
          var b = this.childNodes[1].getBBox();
          var diffX = d.x - d.node.x,
              diffY = d.y - d.node.y;
          var dist = Math.sqrt(diffX * diffX + diffY * diffY);
          var shiftX = Math.min(0, b.width * (diffX - dist) / (dist * 2));
          var shiftY = 5;
          this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
        }
      });
      labelNode.call(updateNode);
    }

    var circleNode = points.selectAll("circle")
        .data(points)
      .enter().append("circle")
        .attr("class", "node")
        .attr("r", 5)
        .style("fill", "#555")
        .style("stroke-width", 3);

    var labelNode = points.selectAll("g")
        .data(force.nodes())
      .enter().append("g")
        .attr("class", "labelNode");

    labelNode.append("circle")
        .attr("r", 0)
        .style("fill", "red");

    labelNode.append("text")
        .text(function(d, i) { return i % 2 == 0 ? "" : d.node.label })
        .style("fill", "#555")
      var updateNode = function() {
        this.attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        });
      }

    force.start();
  });

    </script>
</body>
</html>